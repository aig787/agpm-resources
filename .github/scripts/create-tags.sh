#!/bin/bash
#
# Create and push git tags for versioned artifacts.
#
# Usage: create-tags.sh <tags_file>
#
# The tags_file should contain one tag per line in the format:
# {tool}-{category}-{artifact-name}-v{version}
#

set -e  # Exit on error

TAGS_FILE="$1"

if [ -z "$TAGS_FILE" ]; then
    echo "Error: No tags file specified" >&2
    echo "Usage: $0 <tags_file>" >&2
    exit 1
fi

if [ ! -f "$TAGS_FILE" ]; then
    echo "Error: Tags file not found: $TAGS_FILE" >&2
    exit 1
fi

# Read tags from file
TAGS=$(cat "$TAGS_FILE")

if [ -z "$TAGS" ]; then
    echo "No tags to create"
    exit 0
fi

echo "Creating tags..."
echo

TAG_COUNT=0

while IFS= read -r tag; do
    # Skip empty lines
    if [ -z "$tag" ]; then
        continue
    fi

    # Parse tag name to extract artifact info
    # Format: {tool}-{category}-{name}-v{version}
    TOOL=$(echo "$tag" | cut -d'-' -f1)
    CATEGORY=$(echo "$tag" | cut -d'-' -f2)
    # Name could have multiple hyphens, so we need to extract it carefully
    VERSION=$(echo "$tag" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+$')
    # Extract name by removing tool, category, and version
    NAME=$(echo "$tag" | sed -E "s/^${TOOL}-${CATEGORY}-//; s/-${VERSION}$//")

    # Create tag message
    TAG_MESSAGE="Release ${TOOL}/${CATEGORY}/${NAME} ${VERSION}

This tag marks the release of:
- Tool: ${TOOL}
- Category: ${CATEGORY}
- Artifact: ${NAME}
- Version: ${VERSION}

Generated by automated artifact tagging workflow."

    # Check if tag already exists
    if git rev-parse "$tag" >/dev/null 2>&1; then
        echo "Warning: Tag already exists: $tag (skipping)"
        continue
    fi

    # Create annotated tag
    echo "Creating tag: $tag"
    git tag -a "$tag" -m "$TAG_MESSAGE"

    TAG_COUNT=$((TAG_COUNT + 1))

done <<< "$TAGS"

echo
echo "Created $TAG_COUNT tag(s)"

# Push all tags to remote
if [ $TAG_COUNT -gt 0 ]; then
    echo
    echo "Pushing tags to remote..."
    git push origin --tags
    echo "Done!"
else
    echo "No new tags to push"
fi
